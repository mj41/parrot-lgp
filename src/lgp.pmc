#include "parrot/parrot.h"

pmclass LGP dynpmc need_ext extends Sub {

    void* invoke (void* next) {
        struct Parrot_sub * const sub = PMC_sub(SELF);
        opcode_t *pc;
        opcode_t *pc_end;

        pc = sub->seg->base.data + sub->start_offs;
        pc_end = sub->seg->base.data + sub->end_offs;

//		*(pc + 15) = 413;
//		*(pc + 16) = 7;

		op_info_t* info;
    	int j;


		while ( pc < pc_end ) {
			info = &interpreter->op_info_table[*pc];
		    // p = full_name ? info->full_name : info->name;
	        printf( "%p", pc );

	        printf( " %3i", ( pc - sub->seg->base.data ) / sizeof(*pc) );
		    printf( " +%d", info->op_count );

	        printf( " %4ld", *pc );
		    printf( " %s", info->full_name );
		    for (j = 1; j < info->op_count; j++) {
				INTVAL i = 0;
				switch (info->types[j-1]) {
					case PARROT_ARG_I:
						printf(" I");
						goto INTEGER;
					case PARROT_ARG_N:
						printf(" N");
						goto INTEGER;
					case PARROT_ARG_S:
						printf(" S");
						goto INTEGER;
					case PARROT_ARG_P:
						printf(" P");
						goto INTEGER;
					case PARROT_ARG_IC:
						printf(" ");
						if ((j == info->op_count - 1) &&
							(info->jump & PARROT_JUMP_RELATIVE))
						{
							if (pc[j] > 0) printf("+");
							i = pc[j];
						}

						INTEGER:
						if (i == 0) i = (INTVAL) pc[j];
						printf(INTVAL_FMT, i);
						break;

					default:
						printf( " -unk-" );
						break;

				}
				if (j != info->op_count - 1)
		            printf(",");
		   	}

		    printf( "\n" );
			pc += info->op_count;
		}

		// find INDI_CORE
        pc = sub->seg->base.data + sub->start_offs;

        opcode_t *pc_indi_core_start;
		while ( pc < pc_end ) {
			if ( *pc == 15 ) {
				printf( "bsr to +%ld\n", (INTVAL) pc[1] );
				pc_indi_core_start = pc + pc[1];
				break;
			}
			pc += info->op_count;
		}
		printf( "indi_core start: %p\n", pc_indi_core_start );


        return SUPER(next);
    }
}

