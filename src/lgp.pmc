#include "parrot/parrot.h"

int init_done = 0;
opcode_t *epc_start;
opcode_t *epc_end;
opcode_t *ipc_start;
opcode_t *ipc_end;


typedef struct lgp_indi {
    double          fitness;
    opcode_t		code[100];
    size_t			size;
} t_lgp_indi;


t_lgp_indi pop[1000000];
//opcode_t *code[1000000][100];


static void
dump_from_to( Interp* interpreter, opcode_t *pc, opcode_t *pc_end ) {

	op_info_t* info;
	int j;
	while ( pc < pc_end ) {
		info = &interpreter->op_info_table[*pc];
		// p = full_name ? info->full_name : info->name;
		printf( "%p", pc );

//	        printf( " %3i", ( pc - sub->seg->base.data ) / sizeof(*pc) );
		printf( " +%d", info->op_count );

		printf( " %4ld", *pc );
		printf( " %s", info->full_name );
		for (j = 1; j < info->op_count; j++) {
			INTVAL i = 0;
			switch (info->types[j-1]) {
				case PARROT_ARG_I:
					printf(" I");
					goto INTEGER;
				case PARROT_ARG_N:
					printf(" N");
					goto INTEGER;
				case PARROT_ARG_S:
					printf(" S");
					goto INTEGER;
				case PARROT_ARG_P:
					printf(" P");
					goto INTEGER;
				case PARROT_ARG_IC:
					printf(" ");
					if ((j == info->op_count - 1) &&
						(info->jump & PARROT_JUMP_RELATIVE))
					{
						if (pc[j] > 0) printf("+");
						i = pc[j];
					}

					INTEGER:
					if (i == 0) i = (INTVAL) pc[j];
					printf(INTVAL_FMT, i);
					break;

				default:
					printf( " |" );
					printf(INTVAL_FMT, (INTVAL) pc[j]);
					printf( "|" );
					break;

			}
			if (j != info->op_count - 1)
				printf(",");
		}

		printf( "\n" );
		pc += info->op_count;
	}
}


pmclass LGP dynpmc need_ext extends Sub {


    void* invoke (void* next) {
        struct Parrot_sub * const sub = PMC_sub(SELF);
        opcode_t *pc;
        opcode_t *pc_end;

		if ( ! init_done ) {
			// find INDI_CORE
			op_info_t* info;
			epc_start = sub->seg->base.data + sub->start_offs;
			epc_end = sub->seg->base.data + sub->end_offs;

			pc = epc_start;
			while ( pc < epc_end ) {
				if ( *pc == 15 ) {
					//printf( "bsr to +%ld\n", (INTVAL) pc[1] );
					ipc_start = pc + pc[1];
					break;
				}
				info = &interpreter->op_info_table[*pc];
				pc += info->op_count;
			}
			ipc_end = epc_end;
			init_done = 1;
		}

		return SUPER(next);
	}


    METHOD void init_indi() {
		*epc_start = 1;
	}


    METHOD void new_indi() {
//    init_prederef(interpreter, PARROT_CGP_CORE);
//    pc_prederef = interpreter->code->prederef.code + (pc - code_start);
//    pc = cgp_core((opcode_t*)pc_prederef, interpreter);

		*(ipc_start + 5) = 3;
		*(ipc_start + 9) = 413;
		*(ipc_start + 10) = 25;
		*(ipc_start + 11) = 16;
	}


    METHOD void gvdump() {
		printf( "eval core start: %p\n", epc_start );
		printf( "indi core start: %p\n", ipc_start );
		printf( "indi core end  : %p\n", ipc_end );
		printf( "eval core end  : %p\n", epc_end );
	}


    METHOD void edump() {
		dump_from_to(INTERP, epc_start, epc_end );
    }


    METHOD void idump() {
		dump_from_to(INTERP, ipc_start, ipc_end );
    }


    METHOD STRING* test() {
		char cstr[20];
		char * str = cstr;

        struct Parrot_sub * const sub = PMC_sub(SELF);
        opcode_t *pc;
        pc = sub->seg->base.data + sub->start_offs;

		op_info_t* info;
  		info = &interpreter->op_info_table[*pc];
    	strcpy(str, info->full_name );

		STRING *sstr;
		sstr = string_from_cstring(interpreter, str, strlen(str));
		mem_sys_free(str);
		return sstr;
    }

}

