#include "parrot/parrot.h"
#include "lgp_conf.h"

int init_done = 0;
opcode_t *epc_start;
opcode_t *epc_end;
opcode_t *ipc_start;
opcode_t *ipc_end;


static void
Parrot_dump_from_to( Interp* interp, opcode_t *pc, opcode_t *pc_end ) {

	op_info_t* info;
	int j;
	while ( pc < pc_end ) {
		info = &interp->op_info_table[*pc];
		// p = full_name ? info->full_name : info->name;
		PIO_printf(interp, "%p", pc );

//	        PIO_printf(interp, " %3i", ( pc - sub->seg->base.data ) / sizeof(*pc) );
		PIO_printf(interp, " +%d", info->op_count );

		PIO_printf(interp, " %4ld", *pc );
		PIO_printf(interp, " %s", info->full_name );
		for (j = 1; j < info->op_count; j++) {
			INTVAL i = 0;
			switch (info->types[j-1]) {
				case PARROT_ARG_I:
					PIO_printf(interp," I");
					goto INTEGER;
				case PARROT_ARG_N:
					PIO_printf(interp," N");
					goto INTEGER;
				case PARROT_ARG_S:
					PIO_printf(interp," S");
					goto INTEGER;
				case PARROT_ARG_P:
					PIO_printf(interp," P");
					goto INTEGER;
				case PARROT_ARG_IC:
					PIO_printf(interp," ");
					if ((j == info->op_count - 1) &&
						(info->jump & PARROT_JUMP_RELATIVE))
					{
						if (pc[j] > 0) PIO_printf(interp,"+");
						i = pc[j];
					}

					INTEGER:
					if (i == 0) i = (INTVAL) pc[j];
					PIO_printf(interp, INTVAL_FMT, i);
					break;

				default:
					PIO_printf(interp, " |" );
					PIO_printf(interp, INTVAL_FMT, (INTVAL) pc[j]);
					PIO_printf(interp, "|" );
					break;

			}
			if (j != info->op_count - 1)
				PIO_printf(interp,",");
		}

		PIO_printf(interp, "\n" );
		pc += info->op_count;
	}
}


pmclass LGP dynpmc need_ext extends Sub {

    void* invoke (void* next) {
        struct Parrot_sub * const sub = PMC_sub(SELF);
        opcode_t *pc;
        opcode_t *pc_end;

		// todo - move to init_indi method
		if ( ! init_done ) {
			// find INDI_CORE
			op_info_t* info;
			epc_start = sub->seg->base.data + sub->start_offs;
			epc_end = sub->seg->base.data + sub->end_offs;

			pc = epc_start;
			if ( *pc != 15 ) {
				PIO_printf(INTERP, "First instruction is not bsr\n");
				exit;
			}
			PIO_printf(INTERP, "bsr to +%ld\n", (INTVAL) pc[1] );
			ipc_start = pc + pc[1];
			info = &INTERP->op_info_table[*pc];
			pc += info->op_count;
			ipc_end = epc_end;

			init_done = 1;
		}

		return SUPER(next);
	}


    METHOD void init_indi () {
		// replace "bsr INDI_CORE" with "noop", "noop"
		*(epc_start + 0) = 1;
		*(epc_start + 1) = 1;

		srand((unsigned) time(NULL) );
	}


    METHOD void initialize (INTVAL indi_num) {
		opcode_t *ipc;
		ipc = pop[indi_num].code;
		//PIO_printf(INTERP, "2--- %p %i\n", (ipc+499), *(ipc+499) );
		//ipc = &(pop[indi_num].size);
		//PIO_printf(INTERP, "3--- %p %i\n", ipc, *ipc );

		INTVAL len;
		do {
			len = rand() % MAX_LEN;
		} while ( len < 2 );
		PIO_printf(INTERP, "b--- %p %i (+%i)\n", ipc, *ipc, len );
		ipc = &*(ipc + len);
		PIO_printf(INTERP, "r--- %p %i\n", ipc, *ipc );

		*ipc = (INTVAL)16; // ret

		INTVAL r_op, r_i, j;
		op_info_t *info;
		while ( len > 0 ) {
			do {
				r_op = lgp_ops[ rand() % lgp_op_count ];
	  			info = &INTERP->op_info_table[r_op];
			} while ( info->op_count > len );
			ipc -= info->op_count;
			*ipc = r_op;
			len -= info->op_count;

			for (j = 0; j < (info->op_count-1); j++) {
				switch (info->types[j]) {
					case PARROT_ARG_I:
						r_i = rand() % lgp_in_reg_count;
						*(ipc+j) = r_i;
						break;
					default:
						PIO_eprintf(INTERP, "Can't generate operand with type=%i, op_count=%i\n", info->types[j], info->op_count );
						exit;
						break;
				}
			}
		}


    }


    METHOD void gvdump () {
		PIO_printf(INTERP, "eval code start: %p\n", epc_start );
		PIO_printf(INTERP, "indi core start: %p, indi relative start: %i\n", ipc_start, (INTVAL)(ipc_start-epc_start) );
		PIO_printf(INTERP, "indi core end  : %p, indi relative end  : %i, indi len: %i\n",
			ipc_end,
			(INTVAL)(ipc_end-epc_start),
			(INTVAL)(ipc_end-ipc_start)
		);
		PIO_printf(INTERP, "eval code end  : %p, eval relative end  : %i\n", epc_end, (INTVAL)(epc_end-epc_start) );
	}


    METHOD void edump () {
		Parrot_dump_from_to(INTERP, epc_start, epc_end );
    }


    METHOD void idump () {
		Parrot_dump_from_to(INTERP, ipc_start, ipc_end );
    }


    METHOD INTVAL ops_num () {
		return lgp_op_count;
	}


	METHOD PMC* ops () {
		PMC *array;
		array = pmc_new(interpreter, enum_class_FixedPMCArray);
		VTABLE_set_integer_native(interpreter, array, lgp_op_count );
		int i;
		for ( i = 0; i < lgp_op_count; i++) {
            VTABLE_set_integer_keyed_int(INTERP, array, i, (INTVAL)lgp_ops[i] );
		}
		return array;
	}


    METHOD STRING* test () {
		char cstr[20];
		char *str = cstr;

        struct Parrot_sub * const sub = PMC_sub(SELF);
        opcode_t *pc;
        pc = ipc_start;

		op_info_t* info;
  		info = &interpreter->op_info_table[*pc];
    	strcpy(str, info->full_name );

		STRING *sstr;
		sstr = string_from_cstring(interpreter, str, strlen(str));
		mem_sys_free(str);
		return sstr;
    }

}

