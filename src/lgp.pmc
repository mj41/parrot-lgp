#include "parrot/parrot.h"
#include "lgp_conf.h"

int init_done = 0;
opcode_t *epc_start;
opcode_t *epc_end;
opcode_t *ipc_start;
opcode_t *ipc_end;



static int
Parrot_quicksort_fitness_partition(INTVAL a[], int p, int r) {
	int x = a[r];
	int j = p - 1;
	int i;
	for (i = p; i < r; i++) {
		if ( pop[ x ].fitness <= pop[ a[i] ].fitness ) {
			j = j + 1;
			int temp = a[j];
			a[j] = a[i];
			a[i] = temp;
		}
	}
	a[r] = a[j + 1];
	a[j + 1] = x;

	return (j + 1);
}


static void
Parrot_quicksort_fitness (INTVAL a[], int p, int r) {
	if (p < r) {
		int q = Parrot_quicksort_fitness_partition(a, p, r);
		Parrot_quicksort_fitness(a, p, q - 1);
		Parrot_quicksort_fitness(a, q + 1, r);
	}
}


static void
Parrot_dump_from_to (Interp* interp, opcode_t *pc, opcode_t *pc_end) {

	//PIO_printf(interp, "----- %p\n", pc );
	//PIO_printf(interp, "----- %p\n", pc_end );
	op_info_t* info;
	int j, rop_num, op_num;
	rop_num = 0;
	op_num = 0;
	while ( pc < pc_end ) {
		info = &interp->op_info_table[*pc];
		PIO_printf(interp, "%3i +%1i %3i %p", rop_num, info->op_count, op_num, pc );

		PIO_printf(interp, " %4ld", *pc );
		PIO_printf(interp, " %s", info->full_name );
		for (j = 1; j < info->op_count; j++) {
			INTVAL i = 0;
			switch (info->types[j-1]) {
				case PARROT_ARG_I:
					PIO_printf(interp," I");
					goto INTEGER;
				case PARROT_ARG_N:
					PIO_printf(interp," N");
					goto INTEGER;
				case PARROT_ARG_S:
					PIO_printf(interp," S");
					goto INTEGER;
				case PARROT_ARG_P:
					PIO_printf(interp," P");
					goto INTEGER;
				case PARROT_ARG_IC:
					PIO_printf(interp," ");
					if ((j == info->op_count - 1) &&
						(info->jump & PARROT_JUMP_RELATIVE))
					{
						if (pc[j] > 0) PIO_printf(interp,"+");
						i = pc[j];
					}

					INTEGER:
					if (i == 0) i = (INTVAL) pc[j];
					PIO_printf(interp, INTVAL_FMT, i);
					break;

				default:
					PIO_printf(interp, " |" );
					PIO_printf(interp, INTVAL_FMT, (INTVAL) pc[j]);
					PIO_printf(interp, "|" );
					break;

			}
			if (j != info->op_count - 1)
				PIO_printf(interp,",");
		}

		PIO_printf(interp, "\n" );
		pc += info->op_count;
		rop_num++;
		op_num += info->op_count;
	}
}


pmclass LGP dynpmc need_ext extends Sub {

    void* invoke (void* next) {
		if ( init_done == 2 ) {
			#if 0
				opcode_t *prev;
				prev = &*( (opcode_t *)next - 1 );
	  			PIO_printf(INTERP, "lgp invoke prev op %p %i\n", prev, *prev );
	  			Parrot_dump_from_to(INTERP, prev-30, prev+1 );
	  			PIO_printf(INTERP, "lgp invoke from %p %i\n", (opcode_t *)next, *(opcode_t *)next );
	  			Parrot_dump_from_to(INTERP, (opcode_t *) next, &*(((opcode_t *) next) + 100) );
	  		# endif

		} else if ( init_done == 1 ) {
			PIO_eprintf(INTERP, "You need call prepare_lgp(pop_size) first.");
			Parrot_exit(INTERP, 1);

		} else {
			struct Parrot_sub * const sub = PMC_sub(SELF);
			opcode_t *pc;
			opcode_t *pc_end;

			// find INDI_CORE
			op_info_t* info;
			epc_start = sub->seg->base.data + sub->start_offs;
			epc_end = sub->seg->base.data + sub->end_offs;

			pc = epc_start;
			if ( *pc != 34 ) {
				PIO_eprintf(INTERP, "First instruction is not ret.\n");
				Parrot_exit(INTERP, 1);
			}
			if ( *(pc + 1) != 15 ) {
				PIO_eprintf(INTERP, "Second instruction is not bsr.\n");
				Parrot_exit(INTERP, 1);
			}
			// PIO_printf(INTERP, "bsr to +%ld\n", (INTVAL) pc[2]+1 );
			ipc_start = pc + pc[2] + 1;
			ipc_end = epc_end;

			init_done = 1;
		}

		return SUPER(next);
	}


    METHOD void prepare_lgp (INTVAL t_pop_size) {
		// todo - move a part of code from invoke method here

		if ( init_done == 2 ) {
			PIO_eprintf(INTERP, "You need call prepare_lgp(pop_size) only once.");
			Parrot_exit(INTERP, 1);
		}

		if ( init_done != 1 ) {
			PIO_eprintf(INTERP, "You need invoke eval_body() first.");
			Parrot_exit(INTERP, 1);
		}

		// eval_body sub length have to be more longer or equal as INDI_MAX_LEN
		if ( ipc_end - ipc_start != INDI_MAX_LEN ) {
			if ( ipc_end - ipc_start > INDI_MAX_LEN ) {
				// PIO_eprintf(INTERP, "eval_body() len > INDI_MAX_LEN (%i > %i)\n", ipc_end - ipc_start, INDI_MAX_LEN);
			} else {
				PIO_eprintf(INTERP, "eval_body() != INDI_MAX_LEN len (%i != %i)\n", ipc_end - ipc_start, INDI_MAX_LEN);
				Parrot_exit(INTERP, 1);
			}
		}


		if ( check_op_count ) {
			int j, found = 0;
			for ( j = 0; j < lgp_op_count; j++ ) {
				if ( lgp_ops[j] == 16 ) {
					if ( j != lgp_op_count - 1 ) {
						PIO_eprintf(INTERP, "found 'ret' opcode, but as %i. opcode. seems like lgp_op_count=%i is wrong\n", j+1, lgp_op_count);
						Parrot_exit(INTERP, 1);
					}
					found = 1;
					break;
				}
			}
			if ( found != 1 ) {
				PIO_eprintf(INTERP, "'ret' opcode not found (lgp_op_count=%i)\n", lgp_op_count);
				Parrot_exit(INTERP, 1);
			}
		}

		if ( pop_size > MAX_POP_SIZE ) {
			PIO_eprintf(INTERP, "pop_size <= MAX_POP_SIZE (%i <= %i) failed\n", pop_size, MAX_POP_SIZE);
			Parrot_exit(INTERP, 1);
		}
		pop_size = t_pop_size;

		// randomize
		srand((unsigned) time(NULL) );

		// replace "returncc and bsr INDI_CORE" with "noop", "noop", "noop"
		*(epc_start + 0) = 1;
		*(epc_start + 1) = 1;
		*(epc_start + 2) = 1;

		init_done = 2;
	}


    METHOD void initialize_todebug (INTVAL inum) {
		opcode_t *ipc;

		if ( INDI_MAX_LEN < 27 ) {
			PIO_printf(INTERP, "ERR: INDI_MAX_LEN < 26");
			exit;
		}

		pop[inum].fitness = 0;
		pop[inum].len = INDI_MAX_LEN;

		INTVAL j;
		ipc = pop[inum].code;
		for ( j=0; j<INDI_MAX_LEN; j++ ) {
			*(ipc + j) = 1; // noop
		}

		// print_s S0
		*(ipc + 5) = 412;
		*(ipc + 6) = 0;

		// set_i_ic I4, 666
		*(ipc + 12) =  825;
		*(ipc + 13) =  4;
		*(ipc + 14) =  666;

		// print_s S0
		*(ipc + 20) = 412;
		*(ipc + 21) = 0;

		// ret
		*(ipc + 27) = 16;
		*(ipc + INDI_MAX_LEN - 1) = 16;
    }


    METHOD void initialize (INTVAL inum) {
		opcode_t *ipc_s, *ipc;
		ipc_s = pop[inum].code;

		INTVAL g_last, last;
		g_last = rand() % ( INDI_MAX_LEN - 1 ) + 1;
		pop[inum].fitness = 0;
		pop[inum].len = g_last + 1;

		//PIO_printf(INTERP, "b--- %p %i (+%i)\n", ipc, *ipc, g_last );
		ipc = ipc_s + g_last;
		*ipc = 16; // ret
		//PIO_printf(INTERP, "r--- %p %i\n", ipc, *ipc );
		last = g_last - 1;

//		memcpy(&lgp_used_regs, ipc_src, (INDI_MAX_LEN*sizeof(opcode_t)) );

		INTVAL r_op, r_i, j;
		op_info_t *info;
		while ( last >= 0 ) {
			//PIO_printf(INTERP, "----------------- %i z %i\n", last+1, g_last+1);
			//PIO_printf(INTERP, "r_op: " );
			do {
				r_op = lgp_ops[ rand() % lgp_op_count ];
	  			info = &INTERP->op_info_table[r_op];
				//PIO_printf(INTERP, "%i (%i), ", r_op, info->op_count-1 );
			} while ( info->op_count-1 > last );
			//PIO_printf(INTERP, "%s \n", info->full_name );
			ipc = &*(ipc - info->op_count);
			*ipc = r_op;
			//Parrot_dump_from_to(INTERP, ipc_s, &*(ipc_s + pop[inum].len) );
			//PIO_printf(INTERP, "\n");

			for (j = 0; j < (info->op_count-1); j++) {
				switch (info->types[j]) {
					case PARROT_ARG_I:
						r_i = rand() % (lgp_out_reg_count + lgp_in_reg_count);
						if ( r_i < lgp_out_reg_count ) {
							r_i = lgp_out_regs[ r_i ];
						} else {
							r_i -= lgp_out_reg_count;
							r_i = lgp_in_regs[ r_i ];
						}
						//PIO_printf(INTERP, "r_i %i z %i: %i\n", j+1, (info->op_count-1), r_i );
						*(ipc+j+1) = r_i;
						break;
					default:
						PIO_eprintf(INTERP, "Can't generate operand with type=%i, op_count=%i, op=%i\n", info->types[j], info->op_count, r_op );
						exit;
						break;
				}
			}
			last = last - info->op_count;
			//Parrot_dump_from_to(INTERP, ipc_s, &*(ipc_s + pop[inum].len ) );
		}
    }


    METHOD void indi_code (INTVAL inum) {
		// pop[num] individual code dump
		opcode_t *ipc_s;
		ipc_s = pop[inum].code;
		Parrot_dump_from_to(INTERP, ipc_s, &*(ipc_s + pop[inum].len) );
    }


    METHOD INTVAL indi_len (INTVAL inum) {
		// pop[num] individual len
		return pop[inum].len;
    }


    METHOD INTVAL indi_fitness (INTVAL inum) {
		// pop[num] individual fitness
		return pop[inum].fitness;
    }


    METHOD void set_indi_fitness (INTVAL inum, INTVAL fitness) {
		// set pop[num] individual fitness
		// PIO_eprintf(INTERP, " %i = %i \n", inum,  fitness );
		pop[ inum ].fitness = fitness;
    }


    METHOD void load_indi (INTVAL inum) {
		opcode_t *ipc_src;
		ipc_src = pop[inum].code;
		// PIO_eprintf(INTERP, "Will copy %i bytes, from %p to %p\n", (INDI_MAX_LEN*sizeof(opcode_t)), ipc_src, ipc_start );
		memcpy(ipc_start, ipc_src, (INDI_MAX_LEN*sizeof(opcode_t)) );
	}


	METHOD PMC* get_parents () {
		INTVAL r_inums[4];

		r_inums[0] = rand() % pop_size;

		do {
			r_inums[1] = rand() % pop_size;
		} while ( r_inums[1] == r_inums[0] );

		do {
			r_inums[2] = rand() % pop_size;
		} while ( r_inums[2] == r_inums[0] || r_inums[2] == r_inums[1] );

		do {
			r_inums[3] = rand() % pop_size;
		} while ( r_inums[3] == r_inums[0] || r_inums[3] == r_inums[1] || r_inums[3] == r_inums[2] );

		//PIO_eprintf(INTERP, "unsorted nums: %i (%i), %i (%i), %i (%i), %i (%i)\n", r_inums[0], pop[r_inums[0]].fitness, r_inums[1], pop[ r_inums[1] ].fitness, r_inums[2], pop[ r_inums[2] ].fitness, r_inums[3], pop[ r_inums[3] ].fitness  );
		Parrot_quicksort_fitness(r_inums, 0, 4-1);
		//PIO_eprintf(INTERP, "unsorted nums: %i (%i), %i (%i), %i (%i), %i (%i)\n", r_inums[0], pop[r_inums[0]].fitness, r_inums[1], pop[r_inums[1]].fitness, r_inums[2], pop[r_inums[2]].fitness, r_inums[3], pop[r_inums[3]].fitness  );

		PMC *array;
		array = pmc_new(INTERP, enum_class_FixedPMCArray);
		VTABLE_set_integer_native(INTERP, array, 4);
        VTABLE_set_integer_keyed_int(INTERP, array, 0, r_inums[0] );
        VTABLE_set_integer_keyed_int(INTERP, array, 1, r_inums[1] );
        VTABLE_set_integer_keyed_int(INTERP, array, 2, r_inums[2] );
        VTABLE_set_integer_keyed_int(INTERP, array, 3, r_inums[3] );
		return array;
	}


    METHOD void copy_to_temp (INTVAL inum, INTVAL temp_inum) {
		opcode_t *ipc_src, *ipc_dest;
		ipc_src = pop[inum].code;
		ipc_dest = pop[pop_size + temp_inum].code;
		// PIO_eprintf(INTERP, "Will copy %i bytes, from %p to %p\n", (INDI_MAX_LEN*sizeof(opcode_t)), ipc_src, ipc_start );
		memcpy(ipc_dest, ipc_src, (INDI_MAX_LEN*sizeof(opcode_t)) );
	}


    METHOD void rewrite_by_temp (INTVAL inum, INTVAL temp_inum) {
		opcode_t *ipc_src, *ipc_dest;
		ipc_src = pop[pop_size + temp_inum].code;
		ipc_dest = pop[inum].code;
		// PIO_eprintf(INTERP, "Will copy %i bytes, from %p to %p\n", (INDI_MAX_LEN*sizeof(opcode_t)), ipc_src, ipc_start );
		memcpy(ipc_dest, ipc_src, (INDI_MAX_LEN*sizeof(opcode_t)) );
	}


    METHOD void mutate_temp (INTVAL temp_inum) {
		// [operation code] [operands]*
		opcode_t *ipc_ti;
		ipc_ti = pop[pop_size + temp_inum].code;
	}


    METHOD void load_temp_indi (INTVAL temp_inum) {
		opcode_t *ipc_src;
		ipc_src = pop[pop_size + temp_inum].code;
		// PIO_eprintf(INTERP, "Will copy %i bytes, from %p to %p\n", (INDI_MAX_LEN*sizeof(opcode_t)), ipc_src, ipc_start );
		memcpy(ipc_start, ipc_src, (INDI_MAX_LEN*sizeof(opcode_t)) );
	}


    METHOD void eb_mdump () {
		// eval body memory dump
		PIO_printf(INTERP, "eval code start: %p\n", epc_start );
		PIO_printf(INTERP, "indi core start: %p, indi relative start: %i\n", ipc_start, (INTVAL)(ipc_start-epc_start) );
		PIO_printf(INTERP, "indi core end  : %p, indi relative end  : %i, indi len: %i\n",
			ipc_end,
			(INTVAL)(ipc_end-epc_start),
			(INTVAL)(ipc_end-ipc_start)
		);
		PIO_printf(INTERP, "eval code end  : %p, eval relative end  : %i\n", epc_end, (INTVAL)(epc_end-epc_start) );
	}


    METHOD void eb_cdump () {
		// eval body code dump
		Parrot_dump_from_to(INTERP, epc_start, epc_end);
    }


    METHOD void ei_cdump () {
		// eval body individual part code dump
		Parrot_dump_from_to(INTERP, ipc_start, ipc_end);
    }


    METHOD INTVAL max_pop_size () {
		return (INTVAL) MAX_POP_SIZE;
	}

    METHOD INTVAL pop_size () {
		return pop_size;
	}

    METHOD INTVAL ops_num () {
		return lgp_op_count;
	}


	METHOD PMC* ops () {
		PMC *array;
		array = pmc_new(INTERP, enum_class_FixedPMCArray);
		VTABLE_set_integer_native(INTERP, array, lgp_op_count );
		int i;
		for ( i = 0; i < lgp_op_count; i++) {
            VTABLE_set_integer_keyed_int(INTERP, array, i, (INTVAL)lgp_ops[i] );
		}
		return array;
	}


    METHOD STRING* test () {
		char cstr[20];
		char *str = cstr;

        struct Parrot_sub * const sub = PMC_sub(SELF);
        opcode_t *pc;
        pc = ipc_start;

		op_info_t* info;
  		info = &interpreter->op_info_table[*pc];
    	strcpy(str, info->full_name );

		STRING *sstr;
		sstr = string_from_cstring(interpreter, str, strlen(str));
		mem_sys_free(str);
		return sstr;
    }

}

